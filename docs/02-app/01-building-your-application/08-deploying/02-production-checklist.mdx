---
title: Going to Production
description: Before taking your Next.js application to production, here are some recommendations to ensure the best user experience.
---

Before taking your Next.js application to production, here are some recommendations to ensure the best user experience.

## In General

- Use [caching](#caching) wherever possible.
- Ensure your database and backend are deployed in the same region.
- Aim to ship the least amount of JavaScript possible.
- Defer loading heavy JavaScript bundles until needed.
- Ensure [logging](#logging) is set up.
- Ensure [error handling](#error-handling) is set up.
- Configure the [404](/docs/pages/building-your-application/routing/custom-error#404-page) (Not Found) and [500](/docs/pages/building-your-application/routing/custom-error#500-page) (Error) pages.
- Ensure you are [measuring performance](/docs/pages/building-your-application/optimizing/analytics).
- Run [Lighthouse](https://developers.google.com/web/tools/lighthouse) to check for performance, best practices, accessibility, and SEO. For best results, use a production build of Next.js and use incognito in your browser so results aren't affected by extensions.
- Review [Supported Browsers and Features](/docs/architecture/supported-browsers).
- Improve performance using:
  - [`next/image` and Automatic Image Optimization](/docs/pages/building-your-application/optimizing/images)
  - [Automatic Font Optimization](/docs/pages/building-your-application/optimizing/fonts)
  - [Script Optimization](/docs/pages/building-your-application/optimizing/scripts)
- Improve [loading performance](#loading-performance)
- Consider adding a [Content Security Policy](/docs/pages/building-your-application/configuring/content-security-policy)

## Caching

Caching is essential for improving response times and reducing requests to external services. The App Router in Next.js offers robust caching capabilities, catering to both static and dynamic content as well as server actions.

- **Static Asset Caching:**
  Next.js automatically adds caching headers to immutable assets in **`/public`** or other static directories. Assets like CSS, static images, and other media are ideal candidates for long-term caching as they rarely change. The default caching headers applied are:
  `jsx
Cache-Control: public, max-age=31536000, immutable
`

      This setup ensures that these assets are cached efficiently, reducing load times for returning users.

- **Data Cache for Dynamic Content:**
  Next.js's built-in Data Cache persists results of data fetches across server requests and deployments. By default, fetch requests are cached, allowing data to be reused in subsequent requests. This feature is particularly useful for dynamic content that doesn't change frequently.
- **Server-Side Caching and Revalidation:**
  Caching behavior for dynamic data fetched on the server can be controlled through various strategies. Next.js supports time-based revalidation (automatically refreshing the cache after a set period) and on-demand revalidation (refreshing the cache based on specific events). This ensures that users always receive the most up-to-date content without unnecessary delays.
- **Caching in Server Actions and Route Handlers:**
  Custom caching strategies can be implemented in Server Actions and Route Handlers. Developers can configure fetch requests to adhere to specific caching requirements, including opting for default settings like `force-cache`.
- **Opting Out of Caching:**
  There are scenarios where caching might not be desirable. Next.js allows opting out of the Data Cache for specific fetch requests. This can be achieved with settings such as `cache: 'no-store'` or `revalidate: 0`.

## Reducing JavaScript Size

<details open>
  <summary>Examples</summary>

- [with-dynamic-import](https://github.com/vercel/next.js/tree/canary/examples/with-dynamic-import)

</details>
Optimizing the amount of JavaScript sent to the browser is key for performance. This is particularly important when using the dynamic routing of the App Router. To streamline your JavaScript bundles, consider these tools and strategies:

**Analysis Tools**

- **Import Cost**: A VSCode extension that shows the size of each import, helping you gauge the impact on your bundle.
- **Package Phobia**: Assess the size cost of new development dependencies.
- **Bundle Phobia**: Evaluate how dependencies may increase your bundle sizes.
- **Webpack Bundle Analyzer**: An interactive treemap visualization of webpack output files, offering insights into your bundle composition.
- **bundlejs**: An online bundling and minifying tool, providing data on compressed bundle sizes.

**Optimization Strategies**

- **Server-Side Efficiency**: Optimize server actions for light processing, enhancing performance.
- **Minimizing Client-Side JavaScript**: The App Router's flexibility means complex interactions; reducing client-side JavaScript is crucial for faster page loads and a better user experience.

**Deep Dive with `@next/bundle-analyzer`**

**`@next/bundle-analyzer`** is a powerful tool for visualizing webpack output sizes. It's instrumental in pinpointing which code segments most significantly impact your JavaScript bundle size. This insight is essential for targeted optimizations, such as eliminating or substituting large dependencies, implementing code splitting, or lazy-loading modules. Reducing JavaScript bundle size is vital for faster load times and improved performance, especially for production environments.

**Incorporating `@next/bundle-analyzer`:**

1. **Install**: Run **`npm install @next/bundle-analyzer webpack-bundle-analyzer`**.
2. **Configure**: Update **`next.config.js`** with the bundle analyzer's configuration.
3. **Run Analysis**: Execute **`ANALYZE=true npm run build`** to start the analysis.
4. **Review Findings**: Examine the report to understand and act on bundle size data.

Regular application of this analysis during development and pre-deployment is crucial for delivering efficient code.

## Logging

<details open>
  <summary>Examples</summary>

- [Pino and Logflare Example](https://github.com/Logflare/next-pino-logflare-logging-example)

</details>

Since Next.js runs on both the client and server, there are multiple forms of logging supported:

- `console.log` in the browser
- `stdout` on the server

If you want a structured logging package, we recommend [Pino](https://www.npmjs.com/package/pino). If you're using Vercel, there are [pre-built logging integrations](https://vercel.com/integrations?utm_source=next-site&utm_medium=docs&utm_campaign=next-website#logging) compatible with Next.js.

## Error Handling

<details open>
  <summary>Examples</summary>

- [with-sentry](https://github.com/vercel/next.js/tree/canary/examples/with-sentry)

</details>
Effective error handling is vital for maintaining application stability and providing a seamless user experience, especially with the App Router's dynamic routes and server actions.

1. **Server Actions Error Handling**: Wrap server actions in try-catch blocks to handle exceptions gracefully. Log errors for further analysis and return appropriate responses to the client.

   ```jsx
   export async function serverAction() {
     try {
       // Your logic here
     } catch (error) {
       console.error('Server Action Error:', error)
       // Handle the error appropriately
     }
   }
   ```

2. **Client-Side Error Handling**: Utilize error boundaries in React to catch and handle errors in the UI. This prevents the entire application from crashing due to errors in specific components.
3. **Custom Error Pages**: Implement custom 404 and 500 error pages for handling route not found and server errors, respectively. This improves user experience during unforeseen errors.
4. **Error Logging**: Integrate error logging tools like Sentry to capture, log, and analyze errors. This is crucial for identifying and fixing issues quickly.
5. **Error Monitoring**: Regularly monitor error logs and address issues proactively. This helps in maintaining application health and performance.

By implementing robust error handling strategies, you can ensure that your Next.js App Router application remains reliable and user-friendly under all circumstances.

## Loading Performance

To improve loading performance, you first need to determine what to measure and how to measure it. [Core Web Vitals](https://vercel.com/blog/core-web-vitals?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) is a good industry standard that is measured using your own web browser. If you are not familiar with the metrics of Core Web Vitals, review this [blog post](https://vercel.com/blog/core-web-vitals?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) and determine which specific metric/s will be your drivers for loading performance. Ideally, you would want to measure the loading performance in the following environments:

- In the lab, using your own computer or a simulator.
- In the field, using real-world data from actual visitors.
- Local, using a test that runs on your device.
- Remote, using a test that runs in the cloud.

Once you are able to measure the loading performance, use the following strategies to improve it iteratively so that you apply one strategy, measure the new performance and continue tweaking until you do not see much improvement. Then, you can move on to the next strategy.

- **Optimize Caching**: Use caching strategies suited for dynamic content, as detailed in the caching section.
- **Server Actions Efficiency**: Optimize server actions for quick data retrieval and minimal processing.
- **Minimize JavaScript Load**: Remove unused JavaScript and implement code splitting. Dynamically load components as needed.
  - Setting up your Code Editor to view import costs and sizes
  - Finding alternative smaller packages
  - Dynamically loading components and dependencies
- **Parallel Route Rendering**: Leverage the App Router’s ability to render multiple components in parallel for enhanced performance.
